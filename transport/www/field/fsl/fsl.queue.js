// /field/fsl/fsl.queue.js

/**
 * FslQueueService:
 * - Uses IndexedDB to store queued FslRequest objects.
 * - Methods:
 *    - enqueue(request: FslRequest) -> returns same request with id set
 *    - getAll() -> returns array of plain objects (including id)
 *    - delete(id) -> removes one record
 *    - update(item) -> updates a record by id
 *    - trimToMax(maxItems) -> keep only newest maxItems records
 *
 * Retry / TTL / queue policy is implemented in sw.js (flushQueue).
 */

class FslQueueService {
  constructor(dbName, storeName) {
    this.dbName = dbName;
    this.storeName = storeName;
    this._dbPromise = null;
  }

  openDB() {
    if (this._dbPromise) return this._dbPromise;

    this._dbPromise = new Promise((resolve, reject) => {
      try {
        const req = indexedDB.open(this.dbName, 1);

        req.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.storeName)) {
            db.createObjectStore(this.storeName, {
              keyPath: "id",
              autoIncrement: true,
            });
          }
        };

        req.onsuccess = () => {
          console.log("[SW][Queue] DB open success");
          resolve(req.result);
        };

        req.onerror = () => {
          console.error("[SW][Queue] DB open error:", req.error);
          reject(req.error || new Error("IDB open error"));
        };
      } catch (e) {
        console.error("[SW][Queue] DB open exception:", e);
        reject(e);
      }
    });

    return this._dbPromise;
  }

  async enqueue(request) {
    const db = await this.openDB();

    return new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(this.storeName, "readwrite");
        const store = tx.objectStore(this.storeName);

        // We store plain data (no methods); ID is autoGenerated.
        const data = {
          url: request.url,
          method: request.method,
          headers: request.headers,
          body: request.body,
          created_at: request.created_at,
          retry_count: request.retry_count || 0, // NEW
        };

        const addReq = store.add(data);

        addReq.onsuccess = (event) => {
          const newId = event.target.result;
          request.id = newId;
          console.log("[SW][Queue] Enqueued request id =", newId);
          resolve(request);
        };

        tx.onerror = () => {
          console.error("[SW][Queue] enqueue tx error:", tx.error);
          reject(tx.error || new Error("IDB enqueue tx error"));
        };

        tx.onabort = () => {
          console.error("[SW][Queue] enqueue tx abort:", tx.error);
          reject(tx.error || new Error("IDB enqueue tx abort"));
        };
      } catch (e) {
        console.error("[SW][Queue] enqueue exception:", e);
        reject(e);
      }
    });
  }

  async getAll() {
    const db = await this.openDB();

    return new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(this.storeName, "readonly");
        const store = tx.objectStore(this.storeName);

        const all = [];
        const cursorReq = store.openCursor();

        cursorReq.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            const value = cursor.value || {};
            value.id = cursor.key;
            all.push(value);
            cursor.continue();
          } else {
            console.log("[SW][Queue] Loaded", all.length, "queued items");
            resolve(all);
          }
        };

        cursorReq.onerror = () => {
          console.error("[SW][Queue] cursor error:", cursorReq.error);
          reject(cursorReq.error || new Error("IDB cursor error"));
        };
      } catch (e) {
        console.error("[SW][Queue] getAll exception:", e);
        reject(e);
      }
    });
  }

  async delete(id) {
    const db = await this.openDB();

    return new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(this.storeName, "readwrite");
        const store = tx.objectStore(this.storeName);
        store.delete(id);

        tx.oncomplete = () => {
          console.log("[SW][Queue] Deleted id =", id);
          resolve(true);
        };

        tx.onerror = () => {
          console.error("[SW][Queue] delete tx error:", tx.error);
          reject(tx.error || new Error("IDB delete tx error"));
        };

        tx.onabort = () => {
          console.error("[SW][Queue] delete tx abort:", tx.error);
          reject(tx.error || new Error("IDB delete tx abort"));
        };
      } catch (e) {
        console.error("[SW][Queue] delete exception:", e);
        reject(e);
      }
    });
  }

  // NEW: update an existing record (used for retry_count)
  async update(item) {
    const db = await this.openDB();

    return new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(this.storeName, "readwrite");
        const store = tx.objectStore(this.storeName);

        const data = {
          id: item.id,
          url: item.url,
          method: item.method,
          headers: item.headers,
          body: item.body,
          created_at: item.created_at,
          retry_count: item.retry_count || 0,
        };

        const req = store.put(data);

        req.onsuccess = () => {
          console.log("[SW][Queue] Updated id =", item.id);
          resolve(true);
        };

        tx.onerror = () => {
          console.error("[SW][Queue] update tx error:", tx.error);
          reject(tx.error || new Error("IDB update tx error"));
        };

        tx.onabort = () => {
          console.error("[SW][Queue] update tx abort:", tx.error);
          reject(tx.error || new Error("IDB update tx abort"));
        };
      } catch (e) {
        console.error("[SW][Queue] update exception:", e);
        reject(e);
      }
    });
  }

  // NEW: enforce a maximum queue size (drop oldest)
  async trimToMax(maxItems) {
    if (!maxItems || maxItems <= 0) return;

    const db = await this.openDB();

    return new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(this.storeName, "readwrite");
        const store = tx.objectStore(this.storeName);

        const allReq = store.getAll();
        allReq.onsuccess = () => {
          const items = allReq.result || [];
          if (items.length <= maxItems) {
            resolve(true);
            return;
          }

          // Sort by created_at (oldest first), then by id
          items.sort((a, b) => {
            const ca = a.created_at || 0;
            const cb = b.created_at || 0;
            if (ca !== cb) return ca < cb ? -1 : 1;
            return (a.id || 0) - (b.id || 0);
          });

          const toDelete = items.slice(0, items.length - maxItems);
          for (const item of toDelete) {
            store.delete(item.id);
          }

          console.warn(
            "[SW][Queue] trimToMax removed",
            toDelete.length,
            "items (max =",
            maxItems,
            ")"
          );

          resolve(true);
        };

        allReq.onerror = () => {
          console.error("[SW][Queue] trimToMax getAll error:", allReq.error);
          reject(allReq.error || new Error("IDB trimToMax error"));
        };
      } catch (e) {
        console.error("[SW][Queue] trimToMax exception:", e);
        reject(e);
      }
    });
  }
}

// Expose on global SW scope
self.FslQueueService = FslQueueService;
